use coq::lib::hashcons::{Table, HashconsedType, Hlist, Hstring};
use std::cmp::{Ordering};
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::ops::Deref;
use ocaml::de::{
    Str,
};
use ocaml::values::{
    Cst,
    Dp,
    Ind,
    Kn,
    List,
    Mp,
    Proj,
    UId,
};

pub type HDp = Table<Dp, Hstring>;

/// KnKey - can be used as a hash key for KnMap
pub struct KnKey<'a>(pub &'a Kn);

/// UserOrd - use the user name of the Kn
#[derive(Clone, Copy, Debug)]
pub struct KnUser<'a>(pub &'a Cst);

/// CanOrd - use the canonical name of the Kn
#[derive(Clone, Copy, Debug)]
pub struct KnCan<'a>(pub &'a Cst);

pub type MutInd = Cst;

pub type MpMap<T> = HashMap<Mp, T>;

pub type KnMap<'b, T> = HashMap<KnKey<'b>, T>;

/// The [*_env] modules consider an order on user part of names;
/// the others consider an order on canonical part of names

/// Note: this should be MutInd.UserOrd
pub type MindMapEnv<'b, T> = HashMap<KnUser<'b>, T>;

/// Note: this should be Constant.UserOrd
pub type CMapEnv<'b, T> = HashMap<KnUser<'b>, T>;

impl<'a> Deref for KnKey<'a> {
    type Target = Kn;

    fn deref(&self) -> &Kn {
        self.0
    }
}

impl<'a> Deref for KnUser<'a> {
    type Target = Kn;

    fn deref(&self) -> &Kn {
        self.0.user()
    }
}

impl<'a> Deref for KnCan<'a> {
    type Target = Kn;

    fn deref(&self) -> &Kn {
        self.0.canonical()
    }
}

impl Dp {
    pub fn compare(&self, mut p2: &Self) -> Ordering {
        let mut p1 = self;
        loop {
            if p1 as *const _ == p2 as *const _ { return Ordering::Equal }
            match (self, p2) {
                (&List::Nil, &List::Nil) => return Ordering::Equal,
                (&List::Nil, _) => return Ordering::Less,
                (_, &List::Nil) => return Ordering::Greater,
                (&List::Cons(ref o1), &List::Cons(ref o2)) => {
                    let (ref id1, ref p1_) = **o1;
                    let (ref id2, ref p2_) = **o2;
                    match id1.cmp(id2) {
                        Ordering::Equal => {
                            p1 = p1_;
                            p2 = p2_;
                        },
                        c => return c,
                    }
                }
            }
        }
    }

    pub fn equal(&self, p2: &Self) -> bool {
        let mut p1 = self;
        let mut p2 = p2;
        loop {
            if p1 as *const _ == p2 as *const _ { return true }
            match (p1, p2) {
                (&List::Nil, &List::Nil) => return true,
                (&List::Cons(ref o1), &List::Cons(ref o2)) => {
                    let (ref id1, ref p1_) = **o1;
                    let (ref id2, ref p2_) = **o2;
                    if id1 != id2 { return false }
                    p1 = &*p1_;
                    p2 = &*p2_;
                },
                (_, _) => return false,
            }
        }
    }

    // NOTE: We don't need to implement the hash function separately because it's identical to the
    // one autogenerated for HList.
    pub fn hash(&self) -> i64 {
        <Self as HashconsedType<Hlist<_, _, _, for<'b> fn(&'b Hstring, Str) -> Str>>>::hash(self)
    }

    pub fn hcons<'a>(self, u: &'a HDp) -> Dp {
        self.hashcons(&(u, (), Hstring::hcons))
    }
}

impl UId {
    pub fn equal(&self, y: &Self) -> bool {
        self as *const _ == y as *const _ ||
        {
            let UId(i1, ref id1, ref p1) = *self;
            let UId(i2, ref id2, ref p2) = *y;
            i1 == i2 && id1 == id2 && p1.equal(p2)
        }
    }
}

impl Mp {
    pub fn equal(&self, mp2: &Self) -> bool {
        let mut mp1 = self;
        let mut mp2 = mp2;
        loop {
            if mp1 as *const _ == mp2 as *const _ { return true }
            match (mp1, mp2) {
                (&Mp::File(ref p1), &Mp::File(ref p2)) => return p1.equal(p2),
                (&Mp::Bound(ref id1), &Mp::Bound(ref id2)) => return id1.equal(id2),
                (&Mp::Dot(ref mp1_, ref l1), &Mp::Dot(ref mp2_, ref l2)) => {
                    if l1 != l2 { return false }
                    mp1 = &**mp1_;
                    mp2 = &**mp2_;
                },
                (&Mp::File(_), _) | (&Mp::Bound(_), _) | (&Mp::Dot(_, _), _) => return false,
            }
        }
    }
}

impl Kn {
    pub fn equal(&self, kn2: &Self) -> bool {
        let h1 = self.refhash;
        let h2 = kn2.refhash;
        if 0 <= h1 && 0 <= h2 && h1 != h2 { false }
        else {
            self.label == kn2.label &&
            self.dirpath.equal(&kn2.dirpath) &&
            self.modpath.equal(&kn2.modpath)
        }
    }

    /* let compare (kn1 : kernel_name) (kn2 : kernel_name) =
      if kn1 == kn2 then 0
      else
        let c = String.compare kn1.knlabel kn2.knlabel in
        if not (Int.equal c 0) then c
        else
          let c = DirPath.compare kn1.dirpath kn2.dirpath in
          if not (Int.equal c 0) then c
          else ModPath.compare kn1.modpath kn2.modpath */
}

impl<'a> PartialEq for KnKey<'a> {
    fn eq(&self, kn2: &Self) -> bool {
        if &**self as *const _ == &**kn2 as *const _ { true }
        else {
            let c = self.label == kn2.label;
            if !c { false }
            else {
                // NOTE: equality and comparison = 0 coincide here
                let c = self.dirpath.equal(&kn2.dirpath);
                if !c { false }
                // NOTE: equality and comparison = 0 coincide here
                else { self.modpath.equal(&kn2.modpath) }
            }
        }
    }
}

impl<'a> Eq for KnKey<'a> {}

impl<'a> Hash for KnKey<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // NOTE: This is a bit weird because we're hasing an already-hashed value.  I'm not sure
        // how this affects collision probability, but unless we're using a dummy hasher (which
        // would require us to specify the hashing algorithm everywhere else, which is silly) this
        // might not be a good thing.
        //
        // FIXME: More importantly, the hash caching is fundamentally incompatible with how Rust's
        // regular hash maps go.  For now, just don't cache this.
        /* let h = self.refhash;
        if h < 0 {
            let h = self.dirpath.hash(); */
            Hash::hash(&self.modpath, state);
            Hash::hash(&self.dirpath, state);
            Hash::hash(&self.label, state);
            // /// Ensure positivity on all platforms
            // /// FIXME: Whoa, this is wildly unsafe, in general!
            // self.refhash.hash = h;
        /*} else {
            state.hash(h);
          let { modpath = mp; dirpath = dp; knlabel = lbl; } = kn in
          let h = combine3 (ModPath.hash mp) (DirPath.hash dp) (Label.hash lbl) in
          (* Ensure positivity on all platforms. *)
          let h = h land 0x3FFFFFFF in
          let () = kn.refhash <- h in

        } else { h }
        /* let h = kn.refhash in
        if h < 0 then
          let { modpath = mp; dirpath = dp; knlabel = lbl; } = kn in
          let h = combine3 (ModPath.hash mp) (DirPath.hash dp) (Label.hash lbl) in
          (* Ensure positivity on all platforms. *)
          let h = h land 0x3FFFFFFF in
          let () = kn.refhash <- h in
          h
        else h */
        self.user().hash(state); */
    }
}

impl Cst {
    pub fn canonical(&self) -> &Kn {
        match *self {
            Cst::Same(ref kn) => kn,
            Cst::Dual(ref o) => {
                let (_, ref kn) = **o;
                kn
            },
        }
    }

    pub fn user(&self) -> &Kn {
        match *self {
            Cst::Same(ref kn) => kn,
            Cst::Dual(ref o) => {
                let (ref kn, _) = **o;
                kn
            },
        }
    }
}

impl<'a> PartialEq for KnUser<'a> {
    fn eq(&self, y: &Self) -> bool {
        &**self as *const _ == &**y as *const _ || self.equal(&y)
    }
}

impl<'a> Eq for KnUser<'a> {}

impl<'a> Hash for KnUser<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        KnKey(&**self).hash(state);
    }
}

impl<'a> PartialEq for KnCan<'a> {
    fn eq(&self, y: &Self) -> bool {
        &**self as *const _ == &**y as *const _ || self.equal(&y)
    }
}

impl<'a> Eq for KnCan<'a> {}

impl<'a> Hash for KnCan<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        KnKey(&**self).hash(state);
    }
}

impl MutInd {
    pub fn eq_mind_chk(&self, y: &Self) -> bool {
        KnUser(self) == KnUser(y)
    }
}

impl Cst {
    pub fn eq_con_chk(&self, y: &Self) -> bool {
        KnUser(self) == KnUser(y)
    }
}

impl Ind {
    pub fn eq_ind_chk(&self, y: &Self) -> bool {
        self.pos == y.pos && self.name.eq_mind_chk(&y.name)
    }
}

impl Proj {
    pub fn equal(&self, y: &Self) -> bool {
        // NOTE: because it uses the default KerPair equality, which is Canonical.
        KnCan(&self.0) == KnCan(&y.0) && self.1 == y.1
    }
}
