use coq::lib::hashcons::{Table, HashconsedType, Hlist, Hstring};
use std::borrow::Cow;
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::ops::Deref;
use ocaml::de::{
    Str,
};
use ocaml::values::{
    Cst,
    Dp,
    Ind,
    Kn,
    List,
    Mp,
    Proj,
    UId,
};

/* type Hstring = Table<Str, ()>;
let hcons = Hashcons.simple_hcons Hashcons.Hstring.generate Hashcons.Hstring.hcons () */

/* impl Str {
Hashcons.simple_hcons Hashcons.Hstring.generate Hashcons.Hstring.hcons
} */

// type Bar = <Str as HashconsedType::<()>>::hashcons;

pub type HDp = Table<Dp, Hstring>;

// for<'a> fn(&'a coq::lib::hashcons::make::Table<ocaml::de::Str, ()>, &'a ocaml::de::Str) -> std::borrow::Cow<'a, ocaml::de::Str> {<coq::lib::hashcons::make::Table<T, U>><ocaml::de::Str, ()>::hcons}

// type DpTable = Hlist<Str, Hstring, <Str as HashconsedType>>;
//as HashconsedType::<()>, ()>)::hcons>;

/* impl Dp {
    //List<T>, (H, U)>
    fn hcons(&self, tbl: &Hlist<Str, Hstring, Hstring::hashcons>) -> Cow<Self> {
        // (Table<List<T>, U>, Hstring::)
        // self.hcons(())
        Hlist::hcons
    }
} */

/// KnKey - can be used as a hash key for KnMap
pub struct KnKey<'a>(pub &'a Kn);

/// UserOrd - use the user name of the Kn
#[derive(Clone, Copy, Debug)]
pub struct KnUser<'a>(pub &'a Cst);

/// CanOrd - use the canonical name of the Kn
#[derive(Clone, Copy, Debug)]
pub struct KnCan<'a>(pub &'a Cst);

pub type MutInd = Cst;

pub type MpMap<T> = HashMap<Mp, T>;

pub type KnMap<'b, T> = HashMap<KnKey<'b>, T>;

/// The [*_env] modules consider an order on user part of names;
/// the others consider an order on canonical part of names

/// Note: this should be MutInd.UserOrd
pub type MindMapEnv<'b, T> = HashMap<KnUser<'b>, T>;

/// Note: this should be Constant.UserOrd
pub type CMapEnv<'b, T> = HashMap<KnUser<'b>, T>;

impl<'a> Deref for KnKey<'a> {
    type Target = Kn;

    fn deref(&self) -> &Kn {
        self.0
    }
}

impl<'a> Deref for KnUser<'a> {
    type Target = Kn;

    fn deref(&self) -> &Kn {
        self.0.user()
    }
}

impl<'a> Deref for KnCan<'a> {
    type Target = Kn;

    fn deref(&self) -> &Kn {
        self.0.canonical()
    }
}

impl Dp {
    pub fn equal(&self, p2: &Self) -> bool {
        let mut p1 = self;
        let mut p2 = p2;
        loop {
            if p1 as *const _ == p2 as *const _ { return true }
            match (p1, p2) {
                (&List::Nil, &List::Nil) => return true,
                (&List::Cons(ref o1), &List::Cons(ref o2)) => {
                    let (ref id1, ref p1_) = **o1;
                    let (ref id2, ref p2_) = **o2;
                    if id1 != id2 { return false }
                    p1 = &*p1_;
                    p2 = &*p2_;
                },
                (_, _) => return false,
            }
        }
    }

    // NOTE: We don't need to implement the hash function separately because it's identical to the
    // one autogenerated for HList.
    pub fn hash(&self) -> i64 {
        // (&'a Table<List<T>, U>, V, H)
        <Self as HashconsedType<Hlist<_, _, _, for<'b> fn(&'b Hstring, &'b Str) -> Cow<'b, Str>>>>::hash(self)
        // <Self as HashconsedType::<Hlist</*Str*/_, /*Hstring*/_, /*()*/_, /*for<'b> fn(&'b Hstring, &'b Str) -> Cow<'b, Str>*/_>>>::hash(self)
    }

    pub fn hcons<'a>(&'a self, u: &'a HDp) -> Cow<'a, Dp> {
        // <List::<Str> as HashconsedType::<(Table::<List<Str>, Table<Str, ()>>, (), Baz)>>::hashcons(&dp, &(foo2, (), FOO))
        /*match self.hashcons(&(u, (), Hstring::hcons)) {
            Cow::Borrowed(_) => Cow::Borrowed(self), // Nothing to change; was not in the hash table before.
            Cow::Owned(o) => Cow::Owned(o), // Was in the hash table, so use that one.
        }*/
        self.hashcons(&(u, (), Hstring::hcons))
        // dp.hashcons::<Table::<Str, ()>>(&(foo2, Foo::hcons))
    }
}

impl UId {
    pub fn equal(&self, y: &Self) -> bool {
        self as *const _ == y as *const _ ||
        {
            let UId(i1, ref id1, ref p1) = *self;
            let UId(i2, ref id2, ref p2) = *y;
            i1 == i2 && id1 == id2 && p1.equal(p2)
        }
    }
    //
    // x == y ||
    // let (i1, id1, p1) = x in
    // let (i2, id2, p2) = y in
    // Int.equal i1 i2 && Id.equal id1 id2 && DirPath.equal p1 p2
    //
// pub struct UId(Int, #[serde(deserialize_state)] Str, #[serde(deserialize_state)] Dp);
}

impl Mp {
  /* let rec equal mp1 mp2 = mp1 == mp2 ||
    match mp1, mp2 with
    | MPfile p1, MPfile p2 -> DirPath.equal p1 p2
    | MPbound id1, MPbound id2 -> MBId.equal id1 id2
    | MPdot (mp1, l1), MPdot (mp2, l2) -> String.equal l1 l2 && equal mp1 mp2
    | (MPfile _ | MPbound _ | MPdot _), _ -> false */
    pub fn equal(&self, mp2: &Self) -> bool {
        let mut mp1 = self;
        let mut mp2 = mp2;
        loop {
            if mp1 as *const _ == mp2 as *const _ { return true }
            match (mp1, mp2) {
                (&Mp::File(ref p1), &Mp::File(ref p2)) => return p1.equal(p2),
                (&Mp::Bound(ref id1), &Mp::Bound(ref id2)) => return id1.equal(id2),
                (&Mp::Dot(ref mp1_, ref l1), &Mp::Dot(ref mp2_, ref l2)) => {
                    if l1 != l2 { return false }
                    mp1 = &**mp1_;
                    mp2 = &**mp2_;
                },
                (&Mp::File(_), _) | (&Mp::Bound(_), _) | (&Mp::Dot(_, _), _) => return false,
            }
        }
    }
}

impl Kn {
    pub fn equal(&self, kn2: &Self) -> bool {
        let h1 = self.refhash;
        let h2 = kn2.refhash;
        if 0 <= h1 && 0 <= h2 && h1 != h2 { false }
        else {
            self.label == kn2.label &&
            self.dirpath.equal(&kn2.dirpath) &&
            self.modpath.equal(&kn2.modpath)
        }
    }
    /* let compare (kn1 : kernel_name) (kn2 : kernel_name) =
      if kn1 == kn2 then 0
      else
        let c = String.compare kn1.knlabel kn2.knlabel in
        if not (Int.equal c 0) then c
        else
          let c = DirPath.compare kn1.dirpath kn2.dirpath in
          if not (Int.equal c 0) then c
          else ModPath.compare kn1.modpath kn2.modpath */
}

impl<'a> PartialEq for KnKey<'a> {
    fn eq(&self, kn2: &Self) -> bool {
        if &**self as *const _ == &**kn2 as *const _ { true }
        else {
            let c = self.label == kn2.label;
            if !c { false }
            else {
                // NOTE: equality and comparison = 0 coincide here
                let c = self.dirpath.equal(&kn2.dirpath);
                if !c { false }
                // NOTE: equality and comparison = 0 coincide here
                else { self.modpath.equal(&kn2.modpath) }
            }
        }
    }
}

impl<'a> Eq for KnKey<'a> {}

impl<'a> Hash for KnKey<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // NOTE: This is a bit weird because we're hasing an already-hashed value.  I'm not sure
        // how this affects collision probability, but unless we're using a dummy hasher (which
        // would require us to specify the hashing algorithm everywhere else, which is silly) this
        // might not be a good thing.
        //
        // FIXME: More importantly, the hash caching is fundamentally incompatible with how Rust's
        // regular hash maps go.  For now, just don't cache this.
        /* let h = self.refhash;
        if h < 0 {
            let h = self.dirpath.hash(); */
            Hash::hash(&self.modpath, state);
            Hash::hash(&self.dirpath, state);
            Hash::hash(&self.label, state);
            // /// Ensure positivity on all platforms
            // /// FIXME: Whoa, this is wildly unsafe, in general!
            // self.refhash.hash = h;
        /*} else {
            state.hash(h);
          let { modpath = mp; dirpath = dp; knlabel = lbl; } = kn in
          let h = combine3 (ModPath.hash mp) (DirPath.hash dp) (Label.hash lbl) in
          (* Ensure positivity on all platforms. *)
          let h = h land 0x3FFFFFFF in
          let () = kn.refhash <- h in

        } else { h }
        /* let h = kn.refhash in
        if h < 0 then
          let { modpath = mp; dirpath = dp; knlabel = lbl; } = kn in
          let h = combine3 (ModPath.hash mp) (DirPath.hash dp) (Label.hash lbl) in
          (* Ensure positivity on all platforms. *)
          let h = h land 0x3FFFFFFF in
          let () = kn.refhash <- h in
          h
        else h */
        self.user().hash(state); */
    }
}

impl Cst {
    pub fn canonical(&self) -> &Kn {
        match *self {
            Cst::Same(ref kn) => kn,
            Cst::Dual(ref o) => {
                let (_, ref kn) = **o;
                kn
            },
        }
    }

    pub fn user(&self) -> &Kn {
        match *self {
            Cst::Same(ref kn) => kn,
            Cst::Dual(ref o) => {
                let (ref kn, _) = **o;
                kn
            },
        }
    }
  /* let equal kn1 kn2 =
    let h1 = kn1.refhash in
    let h2 = kn2.refhash in
    if 0 <= h1 && 0 <= h2 && not (Int.equal h1 h2) then false
    else
      Label.equal kn1.knlabel kn2.knlabel &&
      DirPath.equal kn1.dirpath kn2.dirpath &&
      ModPath.equal kn1.modpath kn2.modpath */
    /* let h1 = kn1.refhash in
    let h2 = kn2.refhash in
    if 0 <= h1 && 0 <= h2 && not (Int.equal h1 h2) then false
    else
      Label.equal kn1.knlabel kn2.knlabel &&
      DirPath.equal kn1.dirpath kn2.dirpath &&
      ModPath.equal kn1.modpath kn2.modpath */
}

impl<'a> PartialEq for KnUser<'a> {
    fn eq(&self, y: &Self) -> bool {
        &**self as *const _ == &**y as *const _ || self.equal(&y)
    }
}

impl<'a> Eq for KnUser<'a> {}

impl<'a> Hash for KnUser<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        KnKey(&**self).hash(state);
    }
}

impl<'a> PartialEq for KnCan<'a> {
    fn eq(&self, y: &Self) -> bool {
        &**self as *const _ == &**y as *const _ || self.equal(&y)
    }
}

impl<'a> Eq for KnCan<'a> {}

impl<'a> Hash for KnCan<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        KnKey(&**self).hash(state);
    }
}

/* impl PartialEq for Cst {
    // FIXME: This is a not very nice hack to make sure we have the correct equality for the
    // current HashMaps.  You probably shouldn't rely on this for regular equality.
    fn eq(&self, o: &Self) -> bool {
        self.user_equal(o)
    }
} */

impl MutInd {
    pub fn eq_mind_chk(&self, y: &Self) -> bool {
        KnUser(self) == KnUser(y)
    }
}

impl Cst {
    pub fn eq_con_chk(&self, y: &Self) -> bool {
        KnUser(self) == KnUser(y)
    }
}

impl Ind {
    pub fn eq_ind_chk(&self, y: &Self) -> bool {
        self.pos == y.pos && self.name.eq_mind_chk(&y.name)
    }
}

impl Proj {
    pub fn equal(&self, y: &Self) -> bool {
        // NOTE: because it uses the default KerPair equality, which is Canonical.
        KnCan(&self.0) == KnCan(&y.0) && self.1 == y.1
    }
}
