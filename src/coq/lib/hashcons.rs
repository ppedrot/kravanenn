/// Generic hash-consing.

use coq::lib::hashset::combine;
use ocaml::de::{
    ORef,
    Str,
};
use ocaml::values::{
    List,
};
use std::borrow::{Cow};
use std::sync::{Arc};

pub use self::make::{Table};

/// Hashconsing functorial interface

/// Generic hashconsing signature
///
/// Given an equivalence relation [eq], a hashconsing function is a
/// function that associates the same canonical element to two elements
/// related by [eq]. Usually, the element chosen is canonical w.r.t.
/// physical equality [(==)], so as to reduce memory consumption and
/// enhance efficiency of equality tests.
///
/// In order to ensure canonicality, we need a way to remember the element
/// associated to a class of equivalence; this is done using the table type
/// generated by the [Make] functor.
pub trait HashconsedType<
    /// Type of hashcons functions for the sub-structures contained in [t].
    /// Usually a tuple of functions.
    U,
> {
    /// The actual hashconsing function, using its fist argument to recursively
    /// hashcons substructures. It should be compatible with [eq], that is
    /// [eq x (hashcons f x) = true].
    fn hashcons<'a, 'b>(&'a self, &'a U) -> Cow<'b, Self>
        where Self: ToOwned, U: 'b, 'b: 'a;

    /// A comparison function. It is allowed to use physical equality
    /// on the sub-terms hashconsed by the [hashcons] function, but it should be
    /// insensible to shallow copy of the compared object.
    fn eq(&self, &Self) -> bool;

    /// A hash function passed to the underlying hashtable structure. [hash]
    /// should be compatible with [eq], i.e. if [eq x y = true] then
    /// [hash x = hash y].
    fn hash(&self) -> i64;
}

mod make {
    /// Create a new hashconsing, given canonicalization functions.

    use coq::lib::hashcons::HashconsedType;
    use cuckoo::{CuckooHashMap};
    use std::borrow::{Cow};
    use std::hash::{BuildHasherDefault, Hash, Hasher};
    use std::marker::{PhantomData};

    /// Dummy hasher implementation, used internally.
    ///
    /// The reason this is a dummy is that none of the hashes used in Coq are parametric over the
    /// hash function.  Maybe they *should* be, but since they aren't, having custom state here is
    /// not useful.
    /// TODO: Investigate changing this (but keep in mind that if we choose a different hash
    /// function from the one used by Coq, loading things from .vo files will likely get a lot more
    /// complicated, since we won't be able to assume that their hashes are meaninful).
    /// FIXME: Hey, wait, why can we assume their hashes are meaningful in the checker, anyway?
    /// Couldn't they be any integer an attacker chose?  This might be an exploitable soundness bug
    /// (but hopefully the worst it can lead to is false negatives).
    #[derive(Default)]
    pub struct KeyHasher(i64);

    /// Wrapper around the Key for which we can generate our own Hash and Eq instances.
    pub struct Key<T, U> {
        key: T,
        marker: PhantomData<U>,
    }

    /// The concrete implementation of our concurrent hash table.
    ///
    /// FIXME: We should make something optimized for weak pointers (which would be amenable to
    /// hash consing).
    pub type Htbl<T, U> = CuckooHashMap<Key<T, U>, T, BuildHasherDefault<KeyHasher>>;

    /// Type of hashconsing tables
    pub struct Table<T, U> {
        pub tab: Htbl<T, U>,
        pub u: U,
    }

    impl Hasher for KeyHasher {
        fn finish(&self) -> u64 {
            // FIXME: Ensure this is not negative.
            self.0 as u64
        }

        fn write(&mut self, _bytes: &[u8]) { /* noop */ }

        /// We just use this to directly write our hash to the Hasher.
        fn write_i64(&mut self, i: i64) {
            self.0 = i;
        }
    }

    impl<T, U> Key<T, U> {
        fn new(key: T) -> Self {
            Key {
                key: key,
                marker: PhantomData,
            }
        }
    }

    impl<T, U> Hash for Key<T, U> where T: HashconsedType<U> {
        fn hash<H>(&self, state: &mut H)
            where H: Hasher,
        {
            // When used with the KeyHasher, this will ensure that the final hash is the same as
            // this hash.
            state.write_i64(self.key.hash());
        }
    }

    impl<T, U> PartialEq for Key<T, U> where T: HashconsedType<U> {
        fn eq(&self, other: &Self) -> bool {
            self.key.eq(&other.key)
        }
    }

    impl<T, U> Eq for Key<T, U> where T: HashconsedType<U> {}

    /// This create a hashtable of the hashconsed objects.
    impl<T, U> Table<T, U> where T: HashconsedType<U>,
    {
        pub fn generate(u: U) -> Self {
            let tab = Htbl::with_capacity_and_hash_state(97, Default::default());
            Table {
                tab: tab,
                u: u
            }
        }

        /// Perform the hashconsing of the given object within the table.
        pub fn hcons<'a>(&'a self, x: &'a T) -> Cow<T>
            where
                T: ToOwned,
        {
            let y = x.hashcons(&self.u);
            // t.tab.upsert()
            // t.tab.repr(y.hash(), y)
            y
        }
    }
}

/// list
pub type Hlist<'a, T, U, V, H> = (&'a Table<List<T>, U>, V, H);

impl<'a, T, U, V, H> HashconsedType<Hlist<'a, T, U, V, H>> for List<T>
        where
            T: Clone,
            T: HashconsedType<V>,
            H: for<'b> Fn(&'b U, &'b T) -> Cow<'b, T>,
{
    fn hashcons<'b>(&'b self, th: &'b Hlist<'a, T, U, V, H>) -> Cow<'a, Self> {
        match *self {
            List::Cons(ref o) => {
                let (ref x, ref l) = **o;
                let (ref tab, _, ref h) = *th;
                let x = h(&tab.u, x);
                let l = l.hashcons(th);
                // FIXME: If they both return Borrowed, shouldn't we just return self?  Or is there
                // something else that will prevent that from happening in practice?
                let y = Cow::Owned(List::Cons(ORef(Arc::new((x.into_owned(), l.into_owned())))));
                // t.tab.repr(y.hash(), y)
                y
            },
            List::Nil => Cow::Borrowed(self),
        }
    }

    fn eq(&self, l2: &Self) -> bool {
        self as *const _ == l2 as *const _ ||
        match (self, l2) {
            (&List::Nil, &List::Nil) => true,
            (&List::Cons(ref o1), &List::Cons(ref o2)) => {
                let (ref x1, ref l1) = **o1;
                let (ref x2, ref l2) = **o2;
                x1 as *const _ == x2 as *const _ &&
                l1 as *const _ == l2 as *const _
            },
            _ => false,
        }
    }

    fn hash(&self) -> i64 {
        // FIXME: Overflow.
        self.iter().fold(0, |accu, x| combine::combine(x.hash(), accu))
    }
}

/// string
pub type Hstring = Table<Str, ()>;

impl HashconsedType<()> for Str {
    fn hashcons(&self, _: &()) -> Cow<Self> {
        Cow::Borrowed(self)
    }

    fn eq(&self, s2: &Self) -> bool {
        self == s2
    }

    fn hash(&self) -> i64 {
        // The cast to i64 is safe because casting u8 to i64 is always valid.
        // FIXME: Overflow.
        self.iter().fold(0, |accu, c| accu * 19 + *c as i64)
    }
}

/* /// Wrappers
///
/// These are intended to be used together with instances of the [Make]
/// functor.

pub struct SimpleHCons<T, U>
{
    table: Table<T, U>,
}

pub struct RecursiveHCons<T, U>
{
    table: Table<T, ((T -> T), U)>,
}

/// [simple_hcons f sub obj] creates a new table each time it is applied to any
/// sub-hash function [sub].
impl<T, U> SimpleHCons<T, U>
{
    pub fn simple(u: U) -> Self
        where
            T: HashconsedType<U>,
    {
        SimpleHCons {
            table: table::Table::generate(u),
        }
    }

    pub fn hcons(self, x: T) -> T
        where
            T: HashconsedType<U>,
    {
        table::Table::hcons(self.table, x)
    }
}

impl<T, U> SimpleHCons<T, ((T -> T), U)>
{
    pub fn recursive(u: U) -> Self
    {
        let loop_ = Arc::new(Lazy::new());
        let loop__ = loop_.clone();
        let self_ = move |x| loop__.get().unwrap(x);
        /* let table = SimpleHCons {
            table: table::Table::generate((self_, u))
        }; */
        let table = table::Table::generate((self_, u));
        let hrec = Arc::new(move |x| table::Table::hcons(table, x));
        loop_.get_or_create(move || hrec ).clone()
    }
}

impl<T, Tab, F> Deref for RecursiveHConsWrapper<T, Tab, F> {
    type Target = RecursiveHCons<T, Tab, F>;

impl<T, U, F> RecursiveHCons<T, U, F>
{
    pub fn new(f: F, u: U) -> Arc<Self>
        where
            T: HashconsedType<U>,
    {
  // module Hdir = Hashcons.Hlist(Id)

  // let hcons = Hashcons.recursive_hcons Hdir.generate Hdir.hcons Id.hcons
    let loop_ = Arc::new(Lazy::new());
    let loop__ = loop_.clone();
    let self_ = move |x| loop__.get().unwrap()(x);
    let table = Table::generate(u);
        Table {
                  tab: HTbl::with_capacity_and_hash_state(97, Default::default()),
                  u: (self_, Id.hcons) : (Arc<Lazy<Fn(T, (HTbl<T>, U)) -> T>, (HTbl<T>, U)) where U: Fn(Str, (HTbl<Str>, &())) -> Str
              };
    let hrec = Arc::new(|x|
  let hcons = loop_;
        let self_ = Arc::new(RecursiveHCons {
            table: Lazy::new(),
        });
        // Initialize the table.
        self_.table.get_or_create( move ||
            // The interior pointer is weak, because we have a reference cycle here and want to
            // make sure it gets broken when the outer RecursiveHCons is dropped.
            h((self_.downgrade(), u))
        );
        self_
        // let loop_ = Arc::new(Lazy::new());
        // let loop__ = loop_.clone();
        // let self_ = move |x| loop__.get().unwrap(x);
        // let table = h(self_, u);
        // let hrec = Arc::new(|x| f(table, x));
        // loop_.get_or_create(move || hrec ).clone()
    }

    pub fn hcons(self, x: T) -> T
        where
            F: Fn(&Tab, T) -> T,
    {
        f(&self.table, x)
    }
}

impl<T, Tab, F> Drop for RecursiveHCons<T, Tab, F>
{
    pub fn drop(&mut self) {
        // We have a weak pointer that contains ourselves; make sure to get rid of it!
    }
}*/
