/// Generic hash-consing.

use coq::lib::hashset::combine;
use ocaml::de::{
    ORef,
    Str,
};
use ocaml::values::{
    List,
};
use std::sync::{Arc};

pub use self::make::{Table};

/// Hashconsing functorial interface

/// Generic hashconsing signature
///
/// Given an equivalence relation [eq], a hashconsing function is a
/// function that associates the same canonical element to two elements
/// related by [eq]. Usually, the element chosen is canonical w.r.t.
/// physical equality [(==)], so as to reduce memory consumption and
/// enhance efficiency of equality tests.
///
/// In order to ensure canonicality, we need a way to remember the element
/// associated to a class of equivalence; this is done using the table type
/// generated by the [Make] functor.
pub trait HashconsedType<
    /// Type of hashcons functions for the sub-structures contained in [t].
    /// Usually a tuple of functions.
    U,
> {
    /// The actual hashconsing function, using its fist argument to recursively
    /// hashcons substructures. It should be compatible with [eq], that is
    /// [eq x (hashcons f x) = true].
    fn hashcons<'a>(self, &'a U) -> Self
        where Self: ToOwned;

    /// A comparison function. It is allowed to use physical equality
    /// on the sub-terms hashconsed by the [hashcons] function, but it should be
    /// insensible to shallow copy of the compared object.
    fn eq(&self, &Self) -> bool;

    /// A hash function passed to the underlying hashtable structure. [hash]
    /// should be compatible with [eq], i.e. if [eq x y = true] then
    /// [hash x = hash y].
    fn hash(&self) -> i64;
}

mod make {
    /// Create a new hashconsing, given canonicalization functions.

    use coq::lib::hashcons::HashconsedType;
    use cuckoo::{CuckooHashMap};
    use std::hash::{BuildHasherDefault, Hash, Hasher};
    use std::marker::{PhantomData};

    /// Dummy hasher implementation, used internally.
    ///
    /// The reason this is a dummy is that none of the hashes used in Coq are parametric over the
    /// hash function.  Maybe they *should* be, but since they aren't, having custom state here is
    /// not useful.
    /// TODO: Investigate changing this (but keep in mind that if we choose a different hash
    /// function from the one used by Coq, loading things from .vo files will likely get a lot more
    /// complicated, since we won't be able to assume that their hashes are meaninful).
    /// FIXME: Hey, wait, why can we assume their hashes are meaningful in the checker, anyway?
    /// Couldn't they be any integer an attacker chose?  This might be an exploitable soundness bug
    /// (but hopefully the worst it can lead to is false negatives).
    #[derive(Default)]
    pub struct KeyHasher(i64);

    /// Wrapper around the Key for which we can generate our own Hash and Eq instances.
    pub struct Key<T, U> {
        key: T,
        marker: PhantomData<U>,
    }

    /// The concrete implementation of our concurrent hash table.
    ///
    /// FIXME: We should make something optimized for weak pointers (which would be amenable to
    /// hash consing).
    pub type Htbl<T, U> = CuckooHashMap<Key<T, U>, T, BuildHasherDefault<KeyHasher>>;

    /// Type of hashconsing tables
    pub struct Table<T, U> {
        pub tab: Htbl<T, U>,
        pub u: U,
    }

    impl<T, U> Default for Table<T, U>
        where
            T: HashconsedType<U>,
            U: Default,
    {
        fn default() -> Self {
            Table {
                tab: Htbl::default(),
                u: U::default(),
            }
        }
    }

    impl Hasher for KeyHasher {
        fn finish(&self) -> u64 {
            // FIXME: Ensure this is not negative.
            self.0 as u64
        }

        fn write(&mut self, _bytes: &[u8]) { /* noop */ }

        /// We just use this to directly write our hash to the Hasher.
        fn write_i64(&mut self, i: i64) {
            self.0 = i;
        }
    }

    impl<T, U> Key<T, U> {
        pub fn new(key: T) -> Self {
            Key {
                key: key,
                marker: PhantomData,
            }
        }
    }

    impl<T, U> Hash for Key<T, U> where T: HashconsedType<U> {
        fn hash<H>(&self, state: &mut H)
            where H: Hasher,
        {
            // When used with the KeyHasher, this will ensure that the final hash is the same as
            // this hash.
            state.write_i64(self.key.hash());
        }
    }

    impl<T, U> PartialEq for Key<T, U> where T: HashconsedType<U> {
        fn eq(&self, other: &Self) -> bool {
            self.key.eq(&other.key)
        }
    }

    impl<T, U> Eq for Key<T, U> where T: HashconsedType<U> {}

    /// This create a hashtable of the hashconsed objects.
    impl<T, U> Table<T, U> where T: HashconsedType<U>,
    {
        pub fn generate(u: U) -> Self {
            let tab = Htbl::with_capacity_and_hash_state(97, Default::default());
            Table {
                tab: tab,
                u: u
            }
        }

        /// Perform the hashconsing of the given object within the table.
        pub fn hcons<'a>(&'a self, x: T) -> T
            where
                T: ToOwned,
        {
            let y = x.hashcons(&self.u);
            // t.tab.repr(y.hash(), y)
            y
        }
    }
}

/// list
pub type Hlist<'a, T, U, V, H> = (&'a Table<List<T>, U>, V, H);

impl<'a, T, U, V, H> HashconsedType<Hlist<'a, T, U, V, H>> for List<T>
        where
            T: Clone,
            T: HashconsedType<V>,
            H: for<'b> Fn(&'b U, T) -> T,
{
    fn hashcons<'b>(self, th: &'b Hlist<'a, T, U, V, H>) -> Self {
        let y = match self {
            List::Cons(o) => {
                let (ref x, ref l) = *o;
                let (ref tab, _, ref h) = *th;
                let x = h(&tab.u, x.clone());
                let l = (&*l).clone().hashcons(th);
                List::Cons(ORef(Arc::new((x, l))))
            },
            List::Nil => List::Nil
        };
        // t.tab.repr(y.hash(), y)
        y
    }

    fn eq(&self, l2: &Self) -> bool {
        self as *const _ == l2 as *const _ ||
        match (self, l2) {
            (&List::Nil, &List::Nil) => true,
            (&List::Cons(ref o1), &List::Cons(ref o2)) => {
                &**o1 as *const _ == &**o2 as *const _
            },
            _ => false,
        }
    }

    fn hash(&self) -> i64 {
        // FIXME: Overflow.
        self.iter().fold(0, |accu, x| combine::combine(x.hash(), accu))
    }
}

/// string
pub type Hstring = Table<Str, ()>;

impl HashconsedType<()> for Str {
    fn hashcons(self, _: &()) -> Self {
        self
    }

    fn eq(&self, s2: &Self) -> bool {
        self == s2
    }

    fn hash(&self) -> i64 {
        // The cast to i64 is safe because casting u8 to i64 is always valid.
        // FIXME: Overflow (wait, does overflow actually matter here?)
        self.iter().fold(0, |accu, c| accu * 19 + *c as i64)
    }
}
